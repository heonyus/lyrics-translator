/**
 * YouTube Subtitle Provider
 * Extracts subtitles/captions from YouTube videos
 */

import { BaseProvider } from './base-provider';
import { LRCSearchResult, SongQuery } from '../types/provider.types';

interface YouTubeSubtitle {
  text: string;
  start: number;
  duration: number;
}

interface YouTubeVideoInfo {
  videoId: string;
  title: string;
  author: string;
  duration: number;
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: Array<{
        baseUrl: string;
        name: { simpleText: string };
        languageCode: string;
        kind?: string;
      }>;
    };
  };
}

export class YouTubeProvider extends BaseProvider {
  name = 'YouTube';
  priority = 4; // Lower priority, used as fallback
  confidence = 0.6; // Lower confidence for music videos
  
  private readonly infoUrl = 'https://www.youtube.com/youtubei/v1/player';
  private readonly apiKey = 'AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8'; // Public API key from YouTube
  
  protected requiresApiKey(): boolean {
    return false; // Uses public endpoints
  }
  
  protected async checkAvailability(): Promise<boolean> {
    try {
      // Test with a known video
      const response = await this.fetchWithTimeout(
        'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        { method: 'HEAD' }
      );
      return response.ok;
    } catch {
      return false;
    }
  }
  
  async searchLRC(query: SongQuery): Promise<LRCSearchResult[]> {
    this.updateRequestTime();
    
    try {
      // If we have a YouTube video ID, use it directly
      if (query.youtubeId) {
        const videoInfo = await this.getVideoInfo(query.youtubeId);
        if (videoInfo) {
          return [this.mapToSearchResult(videoInfo, query)];
        }
      }
      
      // Otherwise, search YouTube
      const searchResults = await this.searchVideos(query);
      return searchResults;
    } catch (error) {
      console.error('YouTube search error:', error);
      return [];
    }
  }
  
  async fetchLRC(videoId: string): Promise<string> {
    this.updateRequestTime();
    
    try {
      const videoInfo = await this.getVideoInfo(videoId);
      if (!videoInfo) {
        throw new Error('비디오 정보를 가져올 수 없습니다');
      }
      
      // Get captions URL
      const captionTrack = this.selectBestCaption(videoInfo);
      if (!captionTrack) {
        throw new Error('사용 가능한 자막이 없습니다');
      }
      
      // Fetch captions
      const captions = await this.fetchCaptions(captionTrack.baseUrl);
      
      // Convert to LRC format
      return this.convertToLRC(captions, videoInfo);
    } catch (error) {
      console.error('YouTube fetch error:', error);
      throw error;
    }
  }
  
  private async getVideoInfo(videoId: string): Promise<YouTubeVideoInfo | null> {
    try {
      const body = {
        videoId,
        context: {
          client: {
            hl: 'en',
            gl: 'US',
            clientName: 'WEB',
            clientVersion: '2.20240101.00.00'
          }
        }
      };
      
      const response = await this.fetchWithTimeout(
        `${this.infoUrl}?key=${this.apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body)
        }
      );
      
      if (!response.ok) {
        throw new Error('비디오 정보를 가져올 수 없습니다');
      }
      
      const data = await response.json();
      
      return {
        videoId,
        title: data.videoDetails?.title || '',
        author: data.videoDetails?.author || '',
        duration: parseInt(data.videoDetails?.lengthSeconds || '0') * 1000,
        captions: data.captions
      };
    } catch (error) {
      console.error('Failed to get video info:', error);
      return null;
    }
  }
  
  private async searchVideos(query: SongQuery): Promise<LRCSearchResult[]> {
    try {
      // Use YouTube Data API v3 if available, or scraping as fallback
      const searchQuery = `${query.artist} ${query.title} official`;
      
      // For now, return empty array
      // In production, implement proper YouTube search
      console.warn('YouTube search not fully implemented');
      return [];
    } catch (error) {
      console.error('YouTube search failed:', error);
      return [];
    }
  }
  
  private selectBestCaption(videoInfo: YouTubeVideoInfo): any | null {
    const tracks = videoInfo.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    if (!tracks || tracks.length === 0) {
      return null;
    }
    
    // Prefer auto-generated captions for music (often have better timing)
    const autoGenerated = tracks.find(track => track.kind === 'asr');
    if (autoGenerated) {
      return autoGenerated;
    }
    
    // Otherwise, prefer English
    const english = tracks.find(track => track.languageCode.startsWith('en'));
    if (english) {
      return english;
    }
    
    // Return first available
    return tracks[0];
  }
  
  private async fetchCaptions(url: string): Promise<YouTubeSubtitle[]> {
    try {
      // Add format parameter for JSON3
      const captionUrl = `${url}&fmt=json3`;
      
      const response = await this.fetchWithTimeout(captionUrl);
      if (!response.ok) {
        throw new Error('자막을 가져올 수 없습니다');
      }
      
      const data = await response.json();
      
      if (data.events) {
        return this.parseJson3Format(data.events);
      }
      
      return [];
    } catch (error) {
      console.error('Failed to fetch captions:', error);
      return [];
    }
  }
  
  private parseJson3Format(events: any[]): YouTubeSubtitle[] {
    const subtitles: YouTubeSubtitle[] = [];
    
    for (const event of events) {
      if (event.segs) {
        const text = event.segs
          .map((seg: any) => seg.utf8)
          .join('')
          .trim();
        
        if (text) {
          subtitles.push({
            text,
            start: event.tStartMs || 0,
            duration: event.dDurationMs || 3000
          });
        }
      }
    }
    
    return subtitles;
  }
  
  private mapToSearchResult(videoInfo: YouTubeVideoInfo, query: SongQuery): LRCSearchResult {
    // Extract artist and title from video title
    const { artist, title } = this.parseVideoTitle(videoInfo.title);
    
    // Calculate confidence
    let confidence = this.confidence;
    
    if (query.title) {
      const titleSimilarity = this.calculateStringSimilarity(title || videoInfo.title, query.title);
      confidence *= titleSimilarity;
    }
    
    if (query.artist) {
      const artistSimilarity = this.calculateStringSimilarity(artist || videoInfo.author, query.artist);
      confidence *= artistSimilarity;
    }
    
    return {
      id: videoInfo.videoId,
      title: title || videoInfo.title,
      artist: artist || videoInfo.author,
      duration: videoInfo.duration,
      hasLyrics: !!videoInfo.captions,
      hasWordTiming: false, // YouTube captions are line-based
      hasSyncedLyrics: !!videoInfo.captions,
      provider: this.name,
      confidence: Math.min(confidence, 1.0),
      metadata: {
        videoId: videoInfo.videoId,
        url: `https://www.youtube.com/watch?v=${videoInfo.videoId}`
      }
    };
  }
  
  private parseVideoTitle(title: string): { artist?: string; title?: string } {
    // Common patterns for music videos
    const patterns = [
      /^(.+?)\s*[-–]\s*(.+?)(?:\s*\(.*?\))*$/,
      /^(.+?)\s+by\s+(.+?)$/i,
      /^(.+?):\s*(.+?)$/,
      /^(.+?)\s*\|\s*(.+?)$/
    ];
    
    for (const pattern of patterns) {
      const match = title.match(pattern);
      if (match) {
        return {
          artist: match[1].trim(),
          title: match[2].trim()
        };
      }
    }
    
    return { title: title.trim() };
  }
  
  private convertToLRC(subtitles: YouTubeSubtitle[], videoInfo: YouTubeVideoInfo): string {
    const lines: string[] = [];
    
    // Add metadata
    lines.push(`[ti:${videoInfo.title}]`);
    lines.push(`[ar:${videoInfo.author}]`);
    lines.push('[by:YouTube]');
    lines.push('[re:lyrics-translator]');
    lines.push('[ve:1.0]');
    lines.push('');
    
    // Convert subtitles to LRC format
    for (const subtitle of subtitles) {
      const timestamp = this.msToLrcTimestamp(subtitle.start);
      lines.push(`${timestamp}${subtitle.text}`);
    }
    
    return lines.join('\n');
  }
  
  private msToLrcTimestamp(ms: number): string {
    const totalSeconds = ms / 1000;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    
    const mm = minutes.toString().padStart(2, '0');
    const ss = seconds.toFixed(2).padStart(5, '0');
    
    return `[${mm}:${ss}]`;
  }
}