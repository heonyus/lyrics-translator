import chalk from 'chalk';

// Enhanced pretty console logger with colors, boxes, and animations
export class EnhancedLogger {
  private static instance: EnhancedLogger;
  private sessionStartTime: number;
  private apiCalls: Map<string, { count: number; totalTime: number; successes: number; failures: number }>;
  
  private constructor() {
    this.sessionStartTime = Date.now();
    this.apiCalls = new Map();
  }
  
  static getInstance(): EnhancedLogger {
    if (!EnhancedLogger.instance) {
      EnhancedLogger.instance = new EnhancedLogger();
    }
    return EnhancedLogger.instance;
  }
  
  // Session header
  startSession(taskName: string) {
    const width = 80;
    const padding = Math.max(0, Math.floor((width - taskName.length - 2) / 2));
    
    console.log('\n' + chalk.cyan('‚ïê'.repeat(width)));
    console.log(chalk.cyan('‚ïë') + ' '.repeat(padding) + chalk.bold.white(taskName) + ' '.repeat(width - padding - taskName.length - 2) + chalk.cyan('‚ïë'));
    console.log(chalk.cyan('‚ï†' + '‚ïê'.repeat(width - 2) + '‚ï£'));
    console.log(chalk.cyan('‚ïë') + chalk.gray(` Started: ${new Date().toLocaleString('ko-KR')}`.padEnd(width - 2)) + chalk.cyan('‚ïë'));
    console.log(chalk.cyan('‚ïö' + '‚ïê'.repeat(width - 2) + '‚ïù'));
  }
  
  // Search operation with animation
  search(query: string, type: 'artist-title' | 'combined' | 'query' = 'query') {
    const typeEmoji = {
      'artist-title': 'üé§üéµ',
      'combined': 'üîÄ',
      'query': 'üîç'
    };
    
    console.log('\n' + chalk.bgMagenta.white.bold(' SEARCH ') + ' ' + typeEmoji[type] + ' ' + chalk.magenta(query));
    console.log(chalk.gray('‚îÄ'.repeat(60)));
  }
  
  // API call with visual progress
  apiCall(apiName: string, status: 'start' | 'success' | 'fail' | 'skip', details?: string, data?: any) {
    const statusConfig = {
      start: {
        icon: 'üöÄ',
        color: chalk.cyan,
        bgColor: chalk.bgCyan.black,
        text: 'CALLING'
      },
      success: {
        icon: '‚úÖ',
        color: chalk.green,
        bgColor: chalk.bgGreen.black,
        text: 'SUCCESS'
      },
      fail: {
        icon: '‚ùå',
        color: chalk.red,
        bgColor: chalk.bgRed.white,
        text: 'FAILED '
      },
      skip: {
        icon: '‚è≠Ô∏è',
        color: chalk.yellow,
        bgColor: chalk.bgYellow.black,
        text: 'SKIPPED'
      }
    };
    
    const config = statusConfig[status];
    const timestamp = this.getTimestamp();
    
    // Update API stats
    if (!this.apiCalls.has(apiName)) {
      this.apiCalls.set(apiName, { count: 0, totalTime: 0, successes: 0, failures: 0 });
    }
    const stats = this.apiCalls.get(apiName)!;
    stats.count++;
    if (status === 'success') stats.successes++;
    if (status === 'fail') stats.failures++;
    
    // Pretty output
    const apiLabel = config.bgColor(` ${config.text} `);
    const apiNameFormatted = chalk.bold(apiName.padEnd(20));
    
    console.log(
      `${config.icon} ${timestamp} ${apiLabel} ${apiNameFormatted} ${config.color(details || '')}`
    );
    
    // Additional data if provided
    if (data) {
      if (data.confidence !== undefined) {
        this.confidenceBar(data.confidence);
      }
      if (data.lyricsLength !== undefined) {
        console.log(`   ${chalk.gray('‚îî‚îÄ')} ${chalk.cyan('üìù')} Length: ${chalk.bold(data.lyricsLength)} chars`);
      }
      if (data.hasLRC) {
        console.log(`   ${chalk.gray('‚îî‚îÄ')} ${chalk.green('üéµ')} ${chalk.bold.green('LRC Timestamps Available!')}`);
      }
    }
  }
  
  // Cache status with visual indicator
  cache(hit: boolean, key: string, details?: string) {
    const icon = hit ? 'üíé' : 'üîÑ';
    const status = hit ? chalk.bgGreen.black(' CACHE HIT ') : chalk.bgYellow.black(' CACHE MISS ');
    const color = hit ? chalk.green : chalk.yellow;
    
    console.log(
      `\n${icon} ${this.getTimestamp()} ${status} ${color(key)} ${chalk.gray(details || '')}`
    );
  }
  
  // Database operation with icons
  database(operation: 'save' | 'update' | 'fetch' | 'delete' | 'query', table: string, details?: string) {
    const ops = {
      save: { icon: 'üíæ', color: chalk.green, bg: chalk.bgGreen.black },
      update: { icon: 'üìù', color: chalk.blue, bg: chalk.bgBlue.black },
      fetch: { icon: 'üìö', color: chalk.cyan, bg: chalk.bgCyan.black },
      delete: { icon: 'üóëÔ∏è', color: chalk.red, bg: chalk.bgRed.white },
      query: { icon: 'üîç', color: chalk.magenta, bg: chalk.bgMagenta.white }
    };
    
    const op = ops[operation];
    console.log(
      `${op.icon} ${this.getTimestamp()} ${op.bg(` DB:${operation.toUpperCase()} `)} ${op.color(table)} ${chalk.gray(details || '')}`
    );
  }
  
  // Language detection with flags
  language(detected: string, confidence?: number) {
    const flags: { [key: string]: string } = {
      'ko': 'üá∞üá∑ Korean',
      'ja': 'üáØüáµ Japanese',
      'en': 'üá∫üá∏ English',
      'zh': 'üá®üá≥ Chinese',
      'es': 'üá™üá∏ Spanish',
      'fr': 'üá´üá∑ French',
      'unknown': 'üåç Unknown'
    };
    
    const flag = flags[detected] || flags['unknown'];
    const confText = confidence ? ` (${(confidence * 100).toFixed(0)}% confident)` : '';
    
    console.log(
      `\nüåê ${this.getTimestamp()} ${chalk.bgBlue.white(' LANGUAGE ')} ${chalk.bold.blue(flag)}${chalk.gray(confText)}`
    );
  }
  
  // Progress bar for operations
  progress(current: number, total: number, label: string) {
    const percentage = Math.floor((current / total) * 100);
    const barLength = 40;
    const filled = Math.floor((current / total) * barLength);
    const empty = barLength - filled;
    
    const bar = chalk.green('‚ñà'.repeat(filled)) + chalk.gray('‚ñë'.repeat(empty));
    const percentText = chalk.bold(`${percentage}%`);
    
    process.stdout.write(
      `\rüìä ${label}: [${bar}] ${percentText} (${current}/${total})`
    );
    
    if (current === total) {
      console.log(' ‚úÖ');
    }
  }
  
  // Confidence visualization
  private confidenceBar(confidence: number) {
    const percentage = Math.floor(confidence * 100);
    const stars = Math.floor(confidence * 5);
    
    let color = chalk.red;
    let emoji = 'üòü';
    
    if (confidence >= 0.9) {
      color = chalk.green;
      emoji = 'üåü';
    } else if (confidence >= 0.7) {
      color = chalk.yellow;
      emoji = '‚≠ê';
    } else if (confidence >= 0.5) {
      color = chalk.cyan;
      emoji = 'üí´';
    }
    
    const bar = '‚ñà'.repeat(Math.floor(confidence * 10)).padEnd(10, '‚ñë');
    console.log(
      `   ${chalk.gray('‚îî‚îÄ')} ${emoji} Confidence: ${color(bar)} ${color.bold(`${percentage}%`)}`
    );
  }
  
  // Result summary with statistics
  result(results: any[], bestResult: any) {
    console.log('\n' + chalk.bgGreen.black.bold(' üéØ SEARCH RESULTS '));
    console.log(chalk.green('‚ïê'.repeat(60)));
    
    // Best result
    if (bestResult) {
      console.log(chalk.green.bold('üèÜ Best Match:'));
      console.log(`   ${chalk.cyan('Source:')} ${chalk.bold(bestResult.source)}`);
      console.log(`   ${chalk.cyan('Artist:')} ${bestResult.artist}`);
      console.log(`   ${chalk.cyan('Title:')} ${bestResult.title}`);
      if (bestResult.confidence) {
        this.confidenceBar(bestResult.confidence);
      }
      if (bestResult.syncedLyrics) {
        console.log(`   ${chalk.green.bold('‚ú® LRC Timestamps Available!')}`);
      }
    }
    
    // Other results
    if (results.length > 1) {
      console.log(chalk.gray('\nüìã Alternative Results:'));
      results.slice(1, 4).forEach((result, index) => {
        const conf = result.confidence ? ` (${(result.confidence * 100).toFixed(0)}%)` : '';
        const lrc = result.syncedLyrics ? ' üéµ' : '';
        console.log(chalk.gray(`   ${index + 2}. ${result.source}${conf}${lrc}`));
      });
    }
    
    console.log(chalk.green('‚ïê'.repeat(60)));
  }
  
  // Session summary
  endSession(successCount: number, totalCount: number, timeMs: number) {
    const successRate = totalCount > 0 ? (successCount / totalCount * 100).toFixed(0) : 0;
    const emoji = successCount === 0 ? 'üòî' : successCount === totalCount ? 'üéâ' : '‚ú®';
    
    console.log('\n' + chalk.bgCyan.black.bold(' üìä SESSION SUMMARY '));
    console.log(chalk.cyan('‚ïê'.repeat(60)));
    
    // Success rate with visual bar
    const barLength = 30;
    const filled = Math.floor((successCount / totalCount) * barLength);
    const empty = barLength - filled;
    const bar = chalk.green('‚ñà'.repeat(filled)) + chalk.red('‚ñë'.repeat(empty));
    
    console.log(`${emoji} Success Rate: [${bar}] ${chalk.bold(`${successRate}%`)} (${successCount}/${totalCount})`);
    console.log(`‚è±Ô∏è  Total Time: ${chalk.bold(`${timeMs}ms`)}`);
    
    // API call statistics
    if (this.apiCalls.size > 0) {
      console.log(chalk.cyan('\nüìà API Statistics:'));
      this.apiCalls.forEach((stats, apiName) => {
        const avgTime = stats.totalTime / stats.count;
        const successRate = stats.count > 0 ? (stats.successes / stats.count * 100).toFixed(0) : 0;
        console.log(
          `   ${chalk.bold(apiName.padEnd(20))} ` +
          `Calls: ${chalk.cyan(stats.count)} | ` +
          `Success: ${chalk.green(successRate + '%')} | ` +
          `Avg: ${chalk.yellow(avgTime.toFixed(0) + 'ms')}`
        );
      });
    }
    
    console.log(chalk.cyan('‚ïê'.repeat(60)) + '\n');
  }
  
  // Error with stack trace
  error(context: string, error: any, showStack: boolean = false) {
    console.log('\n' + chalk.bgRed.white.bold(' üö® ERROR ') + ' ' + chalk.red.bold(context));
    console.log(chalk.red('‚îÄ'.repeat(60)));
    
    if (error instanceof Error) {
      console.log(chalk.red('Message: ') + chalk.yellow(error.message));
      if (showStack && error.stack) {
        console.log(chalk.red('Stack Trace:'));
        console.log(chalk.gray(error.stack));
      }
    } else {
      console.log(chalk.red('Error: ') + chalk.yellow(JSON.stringify(error, null, 2)));
    }
    
    console.log(chalk.red('‚îÄ'.repeat(60)));
  }
  
  // Info message with icon
  info(message: string, icon: string = '‚ÑπÔ∏è') {
    console.log(`${icon}  ${this.getTimestamp()} ${chalk.bgBlue.white(' INFO ')} ${chalk.blue(message)}`);
  }
  
  // Success message with celebration
  success(message: string, celebrate: boolean = false) {
    const celebration = celebrate ? ' üéäüéâüéä' : '';
    console.log(
      `\n‚ú® ${this.getTimestamp()} ${chalk.bgGreen.black.bold(' SUCCESS ')} ${chalk.green.bold(message)}${celebration}`
    );
  }
  
  // Warning message
  warning(message: string) {
    console.log(
      `‚ö†Ô∏è  ${this.getTimestamp()} ${chalk.bgYellow.black(' WARNING ')} ${chalk.yellow(message)}`
    );
  }
  
  // Custom divider
  divider(char: string = '‚îÄ', length: number = 60, color: any = chalk.gray) {
    console.log(color(char.repeat(length)));
  }
  
  // Get formatted timestamp
  private getTimestamp(): string {
    const now = new Date();
    const time = now.toLocaleTimeString('ko-KR', { 
      hour12: false, 
      hour: '2-digit', 
      minute: '2-digit', 
      second: '2-digit',
      fractionalSecondDigits: 3
    });
    return chalk.gray(`[${time}]`);
  }
  
  // Table display for data
  table(headers: string[], rows: any[][], title?: string) {
    if (title) {
      console.log('\n' + chalk.bgCyan.black.bold(` ${title} `));
    }
    
    // Calculate column widths
    const widths = headers.map((h, i) => {
      const maxRow = Math.max(...rows.map(r => String(r[i] || '').length));
      return Math.max(h.length, maxRow) + 2;
    });
    
    // Header
    console.log(chalk.cyan('‚îå' + widths.map(w => '‚îÄ'.repeat(w)).join('‚î¨') + '‚îê'));
    console.log(chalk.cyan('‚îÇ') + headers.map((h, i) => chalk.bold(h.padEnd(widths[i]))).join(chalk.cyan('‚îÇ')) + chalk.cyan('‚îÇ'));
    console.log(chalk.cyan('‚îú' + widths.map(w => '‚îÄ'.repeat(w)).join('‚îº') + '‚î§'));
    
    // Rows
    rows.forEach(row => {
      console.log(chalk.cyan('‚îÇ') + row.map((cell, i) => String(cell || '').padEnd(widths[i])).join(chalk.cyan('‚îÇ')) + chalk.cyan('‚îÇ'));
    });
    
    // Footer
    console.log(chalk.cyan('‚îî' + widths.map(w => '‚îÄ'.repeat(w)).join('‚î¥') + '‚îò'));
  }
}

// Enhanced API Timer with visual feedback
export class EnhancedAPITimer {
  private startTime: number;
  private apiName: string;
  private logger: EnhancedLogger;
  
  constructor(apiName: string) {
    this.apiName = apiName;
    this.startTime = Date.now();
    this.logger = EnhancedLogger.getInstance();
    this.logger.apiCall(apiName, 'start', 'Initiating request...');
  }
  
  success(details?: string, data?: any): number {
    const duration = Date.now() - this.startTime;
    this.logger.apiCall(this.apiName, 'success', `${details || 'Completed'} (${duration}ms)`, data);
    return duration;
  }
  
  fail(error?: string): number {
    const duration = Date.now() - this.startTime;
    this.logger.apiCall(this.apiName, 'fail', `${error || 'Unknown error'} (${duration}ms)`);
    return duration;
  }
  
  skip(reason?: string): number {
    const duration = Date.now() - this.startTime;
    this.logger.apiCall(this.apiName, 'skip', `${reason || 'Skipped'} (${duration}ms)`);
    return duration;
  }
}

// Export singleton instance
export const enhancedLogger = EnhancedLogger.getInstance();