# 가라오케 스타일 가사 번역 시스템 PRD (자동 LRC 파이프라인)

## 1. 프로젝트 개요

- **프로젝트 명**: Lyrics Translator - 실시간 가라오케 가사 번역기
- **목표**: 노래 방송에서 가라오케 스타일로 가사를 단어별로 하이라이팅하며 실시간 번역을 표시하는 OBS 오버레이 시스템. 수동 업로드 없이 자동으로 LRC 파일을 검색/다운로드하고 타이밍을 동기화한다.
- **핵심 기술 스택**: Next.js 15, TypeScript, React 19, Framer Motion, Google Translate API, OBS Browser Source

## 2. 핵심 기능 (Features)

- **자동 LRC 검색 파이프라인**:
  - 곡명/아티스트로 자동 LRC 검색 (Spotify, Genius, Musixmatch 등)
  - YouTube Music/Spotify URL 입력 시 메타데이터 자동 추출
  - 다양한 LRC 소스에서 순차적 검색 및 품질 비교
  - AI 기반 가사 타이밍 생성 (LRC 없을 시 폴백)

- **가라오케 스타일 디스플레이**:
  - 단어별 실시간 하이라이팅 애니메이션
  - 부드러운 진행률 표시 및 색상 전환
  - 현재 줄 강조 및 다음 줄 미리보기
  - 커스터마이징 가능한 폰트, 색상, 애니메이션

- **실시간 번역 시스템**:
  - 가사 줄 단위 실시간 번역 (Google Translate API)
  - 다국어 동시 표시 지원
  - 번역 캐싱으로 API 호출 최적화
  - 언어별 폰트 및 크기 자동 조절

- **동기화 및 조정 기능**:
  - 실시간 타이밍 오프셋 조정 (±)
  - 오디오 파형 시각화와 가사 동기화
  - 수동 타이밍 에디터 (구간별 미세 조정)
  - 동기화 프리셋 저장 및 공유

- **OBS 통합**:
  - 투명 배경 브라우저 소스
  - 실시간 컨트롤 패널 (별도 창)
  - 단축키 지원 (재생/정지, 오프셋 조정)
  - 다양한 오버레이 템플릿

## 3. IA (페이지 구조도)

- **컨트롤 패널 (`/`)**:
  - 곡 검색 및 자동 LRC 다운로드
  - 재생 컨트롤 및 타이밍 조정
  - 번역 언어 선택 및 설정
  - 오버레이 스타일 커스터마이징

- **OBS 오버레이 (`/overlay`)**:
  - 투명 배경 가라오케 디스플레이
  - 실시간 가사 하이라이팅
  - 번역문 동시 표시
  - URL 파라미터로 설정 제어

- **설정 페이지 (`/settings`)**:
  - API 키 관리 (Google Translate 등)
  - LRC 소스 우선순위 설정
  - 기본 스타일 테마 저장
  - 동기화 프리셋 관리

## 4. 도메인 설계

`src/domains/` 기준으로 구성

- `lyrics`: LRC 파싱, 타이밍 관리, 가사 데이터 처리
- `lrc-fetcher`: 자동 LRC 검색 및 다운로드 파이프라인
- `metadata`: 곡 정보 추출 (YouTube, Spotify API)
- `karaoke`: 가라오케 렌더링, 단어 하이라이팅, 애니메이션
- `translation`: 실시간 번역 처리, 캐싱, 다국어 지원
- `sync`: 타이밍 동기화, 오프셋 조정, 수동 에디터
- `overlay`: OBS 오버레이 렌더링, 투명도 처리
- `settings`: 사용자 설정, API 키, 스타일 테마 관리
- `ui`: 컨트롤 패널, 검색 UI, 설정 컴포넌트

## 5. 자동 LRC 파이프라인 설계

### 5.1 LRC 소스 프로바이더

```typescript
// LRC 제공자 인터페이스
interface LRCProvider {
  name: string;
  priority: number;
  searchLRC(query: SongQuery): Promise<LRCSearchResult[]>;
  fetchLRC(lrcId: string): Promise<string>;
  confidence: number; // 0-1, 신뢰도
}

// 검색 쿼리
interface SongQuery {
  title: string;
  artist: string;
  album?: string;
  duration?: number;
  isrc?: string; // International Standard Recording Code
  spotifyId?: string;
  youtubeId?: string;
}
```

### 5.2 프로바이더 구현체

1. **Spotify Lyrics API** (비공식)
   - Spotify 웹 플레이어의 가사 API 활용
   - 높은 정확도, 공식 타이밍
   - 단어별 타이밍 지원

2. **Genius API**
   - 가사 텍스트만 제공 (타이밍 없음)
   - AI 타이밍 생성 필요
   - 메타데이터 풍부

3. **Musixmatch API**
   - 상업용 API (유료)
   - 정확한 줄별 타이밍
   - 번역된 가사도 제공

4. **LRClib.net**
   - 무료 오픈 소스
   - 커뮤니티 기반 LRC
   - REST API 제공

5. **YouTube 자막**
   - 음악 비디오의 자막 추출
   - 타이밍 정확도 변동
   - ytdl-core 활용

### 5.3 파이프라인 로직

```pseudocode
// 자동 LRC 검색 파이프라인
async function autoFetchLRC(input: string | SongQuery): Promise<LRCResult> {
  // 1. 입력 분석 및 메타데이터 추출
  songQuery = await extractMetadata(input)
  
  // 2. 병렬로 모든 프로바이더 검색
  const providers = [SpotifyProvider, MusixmatchProvider, LRClibProvider, ...]
  const searchPromises = providers.map(p => p.searchLRC(songQuery))
  const allResults = await Promise.allSettled(searchPromises)
  
  // 3. 결과 점수 계산 및 정렬
  const scoredResults = calculateConfidence(allResults, songQuery)
  const bestResult = scoredResults[0]
  
  // 4. LRC 다운로드 및 검증
  if (bestResult.confidence > 0.8) {
    const lrcContent = await bestResult.provider.fetchLRC(bestResult.id)
    return { success: true, lrc: lrcContent, source: bestResult.provider.name }
  }
  
  // 5. 폴백: AI 기반 타이밍 생성
  if (bestResult.hasLyrics && !bestResult.hasTiming) {
    const timedLRC = await generateTimingWithAI(bestResult.lyrics, songQuery.duration)
    return { success: true, lrc: timedLRC, source: 'AI Generated' }
  }
  
  // 6. 수동 입력 요청
  return { success: false, fallback: 'manual' }
}

// 메타데이터 추출
async function extractMetadata(input: string): Promise<SongQuery> {
  // URL 패턴 검사
  if (isSpotifyURL(input)) {
    return await fetchSpotifyMetadata(extractSpotifyId(input))
  }
  if (isYouTubeURL(input)) {
    return await fetchYouTubeMetadata(extractYouTubeId(input))
  }
  
  // 텍스트 검색 쿼리 파싱
  return parseSearchQuery(input) // "아티스트 - 곡명" 형식 등
}

// 신뢰도 점수 계산
function calculateConfidence(results: LRCSearchResult[], query: SongQuery): ScoredResult[] {
  return results.map(result => {
    let score = result.provider.confidence
    
    // 제목 일치도
    score *= stringSimilarity(result.title, query.title)
    
    // 아티스트 일치도
    score *= stringSimilarity(result.artist, query.artist)
    
    // 재생 시간 일치도 (±5초)
    if (query.duration && result.duration) {
      const timeDiff = Math.abs(query.duration - result.duration)
      score *= timeDiff < 5000 ? 1 : Math.max(0, 1 - timeDiff / 30000)
    }
    
    // 단어별 타이밍 여부
    score *= result.hasWordTiming ? 1.2 : 0.8
    
    return { ...result, confidence: score }
  }).sort((a, b) => b.confidence - a.confidence)
}

// AI 타이밍 생성 (Whisper 등 활용)
async function generateTimingWithAI(lyrics: string, audioDuration: number): Promise<string> {
  // 1. 오디오 파일 필요 (YouTube 등에서 추출)
  const audioFile = await fetchAudioFile()
  
  // 2. Whisper API로 음성 인식 및 타이밍 추출
  const whisperResult = await whisperAPI.transcribe(audioFile, {
    language: 'auto',
    timestamps: 'word',
    prompt: lyrics // 가사를 프롬프트로 제공하여 정확도 향상
  })
  
  // 3. 가사와 인식 결과 매칭
  const alignedLyrics = alignLyricsWithTranscription(lyrics, whisperResult)
  
  // 4. LRC 포맷으로 변환
  return convertToLRC(alignedLyrics)
}
```

## 6. 주요 컴포넌트 설계

### 6.1 LRC Fetcher Manager
```typescript
class LRCFetcherManager {
  private providers: LRCProvider[] = [];
  private cache: Map<string, CachedLRC> = new Map();
  
  async searchSong(query: string): Promise<LRCSearchResult[]> {
    // 캐시 확인
    const cacheKey = this.generateCacheKey(query);
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!.results;
    }
    
    // 메타데이터 추출
    const metadata = await this.extractMetadata(query);
    
    // 병렬 검색
    const results = await this.searchAllProviders(metadata);
    
    // 캐시 저장
    this.cache.set(cacheKey, {
      results,
      timestamp: Date.now(),
      query: metadata
    });
    
    return results;
  }
  
  async downloadBestMatch(result: LRCSearchResult): Promise<ParsedLRC> {
    const lrcContent = await result.provider.fetchLRC(result.id);
    return this.parseLRC(lrcContent);
  }
}
```

### 6.2 실시간 동기화 시스템

```typescript
class SyncManager {
  private offset: number = 0; // 밀리초 단위 오프셋
  private playbackRate: number = 1.0;
  
  // 실시간 오프셋 조정
  adjustOffset(delta: number) {
    this.offset += delta;
    this.emit('offsetChanged', this.offset);
  }
  
  // 현재 재생 시간 계산
  getCurrentTime(audioTime: number): number {
    return (audioTime * this.playbackRate) + this.offset;
  }
  
  // 자동 동기화 (오디오 파형 분석)
  async autoSync(audioBuffer: AudioBuffer, lrcData: ParsedLRC) {
    // 1. 오디오에서 비트/음성 onset 검출
    const audioOnsets = this.detectOnsets(audioBuffer);
    
    // 2. LRC의 첫 단어 타이밍과 매칭
    const lrcOnsets = lrcData.lines.map(line => line.words[0]?.startTime).filter(Boolean);
    
    // 3. 최적 오프셋 계산 (Dynamic Time Warping)
    this.offset = this.calculateOptimalOffset(audioOnsets, lrcOnsets);
  }
}
```

### 6.3 가라오케 렌더러
```typescript
interface KaraokeRenderer {
  currentLine: number;
  currentWord: number;
  progress: number; // 0-1
  
  render(currentTime: number): JSX.Element {
    const line = this.lrcData.lines[this.currentLine];
    const word = line.words[this.currentWord];
    
    return (
      <div className="karaoke-display">
        {/* 이전 줄 (페이드 아웃) */}
        <div className="prev-line fade-out">
          {this.renderLine(this.currentLine - 1)}
        </div>
        
        {/* 현재 줄 (하이라이팅) */}
        <div className="current-line">
          {line.words.map((w, i) => (
            <span 
              key={i}
              className={cn({
                'highlighted': i < this.currentWord,
                'highlighting': i === this.currentWord,
                'pending': i > this.currentWord
              })}
              style={{
                '--progress': i === this.currentWord ? this.progress : 0
              }}
            >
              {w.word}
            </span>
          ))}
        </div>
        
        {/* 번역문 */}
        <div className="translation">
          {line.translation}
        </div>
        
        {/* 다음 줄 (페이드 인) */}
        <div className="next-line fade-in">
          {this.renderLine(this.currentLine + 1)}
        </div>
      </div>
    );
  }
}
```

## 7. API 사용 방식

### 7.1 LRC 소스 API들

**Spotify (비공식)**
```typescript
// Spotify Web API의 숨겨진 엔드포인트 활용
const response = await fetch(`https://spclient.wg.spotify.com/color-lyrics/v2/track/${trackId}`, {
  headers: {
    'Authorization': `Bearer ${spotifyAccessToken}`,
    'app-platform': 'WebPlayer'
  }
});
```

**LRClib.net**
```typescript
// 무료 오픈 API
const response = await fetch(`https://lrclib.net/api/search?q=${encodeURIComponent(query)}`);
const results = await response.json();
```

**Genius API**
```typescript
// 가사만 제공 (타이밍 없음)
const genius = new Genius(GENIUS_ACCESS_TOKEN);
const song = await genius.songs.search(query);
const lyrics = await genius.lyrics(song.id);
```

### 7.2 번역 API

**Google Translate**
```typescript
const translate = new Translate({ key: GOOGLE_API_KEY });
const [translation] = await translate.translate(text, targetLang);
```

## 8. 유저 플로우 (Mermaid)

```mermaid
graph TD
    A[방송 시작] --> B[컨트롤 패널 열기]
    B --> C{LRC 검색 방법}
    
    C -->|URL 입력| D[YouTube/Spotify URL 붙여넣기]
    C -->|텍스트 검색| E[아티스트 - 곡명 입력]
    C -->|수동 업로드| F[LRC 파일 선택]
    
    D --> G[메타데이터 자동 추출]
    E --> G
    G --> H[LRC 소스 병렬 검색]
    
    H --> I[검색 결과 표시]
    I --> J{최적 결과 선택}
    
    J -->|자동 선택| K[신뢰도 높은 LRC 다운로드]
    J -->|수동 선택| L[사용자가 결과 선택]
    F --> M[LRC 파싱]
    K --> M
    L --> M
    
    M --> N{타이밍 정보 있음?}
    N -->|Yes| O[가라오케 준비 완료]
    N -->|No| P[AI 타이밍 생성]
    P --> O
    
    O --> Q[OBS 오버레이 시작]
    Q --> R[음악 재생 시작]
    
    R --> S[실시간 동기화]
    S --> T{동기화 조정 필요?}
    T -->|Yes| U[오프셋 조정 (+/- 키)]
    U --> S
    T -->|No| V[가라오케 진행]
    
    V --> W[단어별 하이라이팅]
    W --> X[실시간 번역 표시]
    X --> Y{곡 종료?}
    Y -->|No| W
    Y -->|Yes| Z[다음 곡 준비]
    Z --> C
    
    subgraph "자동 LRC 파이프라인"
        AA[Spotify API]
        AB[LRClib.net]
        AC[Genius + AI]
        AD[YouTube 자막]
        AE[Musixmatch]
    end
    
    H --> AA
    H --> AB
    H --> AC
    H --> AD
    H --> AE
```

## 9. 시스템 아키텍처

```mermaid
graph TB
    subgraph "Control Panel (Main Window)"
        A[SearchInput] --> B[LRCFetcherManager]
        B --> C[MetadataExtractor]
        C --> D[ProviderOrchestrator]
        D --> E[LRCProviders]
        F[SyncControls] --> G[SyncManager]
        H[StyleEditor] --> I[ThemeManager]
    end
    
    subgraph "OBS Overlay (Browser Source)"
        J[OverlayRenderer] --> K[KaraokeDisplay]
        K --> L[WordHighlighter]
        K --> M[TranslationDisplay]
        N[TimingEngine] --> K
        O[AnimationEngine] --> L
    end
    
    subgraph "Shared State"
        P[WebSocket/BroadcastChannel]
        Q[localStorage]
        R[URL Parameters]
    end
    
    subgraph "External APIs"
        S[Spotify Web API]
        T[YouTube Data API]
        U[LRClib.net API]
        V[Genius API]
        W[Google Translate API]
        X[OpenAI Whisper API]
    end
    
    D --> S
    D --> T
    D --> U
    D --> V
    M --> W
    D --> X
    
    G --> P
    I --> P
    P --> N
    P --> M
    
    B --> Q
    Q --> J
    R --> J
```

## 10. 데이터 구조

```typescript
// 자동 검색된 LRC 캐시
interface LRCCache {
  [songId: string]: {
    query: SongQuery;
    results: LRCSearchResult[];
    selectedLRC: ParsedLRC;
    source: string;
    confidence: number;
    timestamp: number;
    syncOffset: number;
  }
}

// 사용자 설정
interface UserSettings {
  // API 설정
  apiKeys: {
    google?: string;
    spotify?: string;
    genius?: string;
    openai?: string;
  };
  
  // LRC 소스 우선순위
  lrcProviders: {
    priority: string[]; // ['spotify', 'lrclib', 'genius', ...]
    enabledProviders: Set<string>;
    autoFallback: boolean;
    useAITiming: boolean;
  };
  
  // 번역 설정
  translation: {
    enabled: boolean;
    targetLanguages: string[];
    cacheEnabled: boolean;
    provider: 'google' | 'deepl' | 'openai';
  };
  
  // 디스플레이 설정
  display: {
    theme: 'dark' | 'light' | 'custom';
    fontSize: {
      lyrics: number;
      translation: number;
    };
    colors: {
      background: string;
      text: string;
      highlight: string;
      translation: string;
    };
    animation: {
      wordTransition: 'fade' | 'slide' | 'scale';
      lineTransition: 'fade' | 'slide' | 'bounce';
      highlightStyle: 'fill' | 'underline' | 'glow';
    };
  };
  
  // 동기화 설정
  sync: {
    autoSync: boolean;
    defaultOffset: number;
    savedOffsets: {
      [songId: string]: number;
    };
  };
}

// 실시간 상태
interface PlaybackState {
  currentSong: SongQuery;
  lrcData: ParsedLRC;
  currentTime: number;
  currentLine: number;
  currentWord: number;
  offset: number;
  isPlaying: boolean;
  translations: Map<number, string>; // line index -> translated text
}
```

## 11. 추가 고려사항

### 🎯 **성능 최적화**
- LRC 검색 결과 캐싱 (24시간)
- 번역 결과 영구 캐싱
- Web Worker에서 타이밍 계산
- RequestAnimationFrame 최적화
- 가상 스크롤링 (긴 가사)

### 🔧 **에러 처리**
- LRC 검색 실패 시 다음 프로바이더 자동 시도
- 타이밍 정보 없을 시 AI 생성 제안
- 번역 API 실패 시 로컬 캐시 사용
- 네트워크 오류 시 오프라인 모드

### 🎨 **사용자 경험**
- 드래그 앤 드롭 LRC 업로드
- 실시간 미리보기
- 단축키 지원 (Space: 재생/정지, ←→: 오프셋)
- 자동 저장 및 복구
- 다크/라이트 테마 자동 전환

### 🌐 **확장성**
- 플러그인 시스템 (커스텀 LRC 프로바이더)
- 커뮤니티 LRC 공유
- 다양한 오버레이 템플릿
- API 래퍼 라이브러리 제공

### 🔒 **저작권 고려**
- LRC 출처 명시
- DMCA 준수
- 상업적 사용 제한 안내

## 12. 구현 우선순위

### Phase 1: MVP (1주)
1. LRClib.net 연동 (무료, 간단)
2. 기본 가라오케 렌더링
3. 수동 오프셋 조정
4. Google Translate 연동
5. OBS 오버레이 페이지

### Phase 2: 자동화 (2주)
1. YouTube/Spotify 메타데이터 추출
2. 다중 LRC 소스 검색
3. 신뢰도 기반 자동 선택
4. 번역 캐싱
5. 스타일 커스터마이징

### Phase 3: 고급 기능 (3주)
1. Spotify 가사 API 리버스 엔지니어링
2. Whisper API 타이밍 생성
3. 오디오 파형 동기화
4. 플러그인 시스템
5. 커뮤니티 기능

## 13. 결론

본 시스템은 수동 LRC 업로드의 번거로움을 해결하는 자동화된 가라오케 가사 시스템이다. 다양한 LRC 소스를 지능적으로 검색하고, 최적의 결과를 자동 선택하며, 실시간 번역과 함께 전문적인 가라오케 경험을 제공한다. OBS 방송에 최적화된 투명 오버레이로 시청자에게 몰입감 있는 노래 방송을 선사할 수 있다.

